name: "Build and Deploy Sanity"
description: "Build and deploy Sanity Studio and/or GraphQL API to Sanity hosted services"
author: "Sanity.io"

inputs:
  token:
    description: "Sanity deploy token"
    required: true
  project-path:
    description: "Path to Sanity project"
    required: false
    default: "."
  build:
    description: "Build project before deploying"
    required: false
    default: "true"
  output-path:
    description: "Path to build output directory"
    required: false
    default: "dist"
  cache-dependencies:
    description: "Cache project dependencies"
    required: false
    default: "true"
  upload-artifacts:
    description: "Upload build artifacts"
    required: false
    default: "false"
  artifact-name:
    description: "Name for uploaded artifacts"
    required: false
    default: "sanity-build"
  no-minify:
    description: "Skip minification during build"
    required: false
    default: "false"
  schema-path:
    description: "Path to schema file for build"
    required: false
    default: ""
  schema-required:
    description: "Fail the deployment if the schema is unserializable"
    required: false
    default: "true"
  deploy-studio:
    description: "Deploy Sanity Studio"
    required: false
    default: "true"
  deploy-graphql:
    description: "Deploy GraphQL API"
    required: false
    default: "false"
  source-maps:
    description: "Include source maps in deployment"
    required: false
    default: "false"
  environment-variables:
    description: "Additional environment variables (KEY=value format, one per line)"
    required: false
    default: ""
  comment-on-pr:
    description: "Comment deployment URL on pull request"
    required: false
    default: "true"
  wait-for-deployment:
    description: "Wait for deployment to be ready"
    required: false
    default: "true"
  deployment-timeout:
    description: "Deployment timeout in seconds"
    required: false
    default: "30"
  graphql-override-tag:
    description: "Override GraphQL API deployment tag"
    required: false
    default: ""
  graphql-override-dataset:
    description: "Override GraphQL API deployment dataset"
    required: false
    default: ""
  graphql-override-playground:
    description: "Override GraphQL playground"
    required: false
    default: ""
  graphql-override-generation:
    description: "Override GraphQL schema generation strategy"
    required: false
    default: ""
  graphql-override-non-null-document-fields:
    description: "Override GraphQL document fields non-nullable"
    required: false
    default: ""
  graphql-override-with-union-cache:
    description: "Override enable union cache that optimizes schema generation for schemas with many self referencing types. This is an experimental feature."
    required: false
    default: ""
  cli-version:
    description: "The version of the Sanity CLI to use"
    required: false
    default: ""
  create-github-deployment:
    description: "Create GitHub deployment status for studio and GraphQL deployments"
    required: false
    default: "true"
  github-token:
    description: "GitHub token for creating deployments (defaults to GITHUB_TOKEN)"
    required: false
    default: ""

outputs:
  build-path:
    description: "Path to build output"
    value: ${{ steps.build-project.outputs.path }}
  build-size:
    description: "Size of build output"
    value: ${{ steps.build-project.outputs.size }}
  studio-url:
    description: "Deployed studio URL"
    value: ${{ steps.deploy-studio.outputs.url }}
  deployment-id:
    description: "Deployment identifier"
    value: ${{ steps.deploy-studio.outputs.id }}
  graphql-url:
    description: "GraphQL API endpoint URL"
    value: ${{ steps.deploy-graphql.outputs.url }}
  graphql-playground-url:
    description: "GraphQL playground URL"
    value: ${{ steps.deploy-graphql.outputs.playground }}

runs:
  using: "composite"
  steps:
    - name: Get dependency hash
      if: inputs.build == 'true'
      id: dep-hash
      shell: bash
      working-directory: ${{ inputs.project-path }}
      run: |
        if [ -f "package-lock.json" ]; then
          echo "hash=${{ hashFiles('**/package-lock.json') }}" >> $GITHUB_OUTPUT
        elif [ -f "yarn.lock" ]; then
          echo "hash=${{ hashFiles('**/yarn.lock') }}" >> $GITHUB_OUTPUT
        elif [ -f "pnpm-lock.yaml" ]; then
          echo "hash=${{ hashFiles('**/pnpm-lock.yaml') }}" >> $GITHUB_OUTPUT
        else
          echo "hash=${{ hashFiles('**/package.json') }}" >> $GITHUB_OUTPUT
        fi

    - name: Cache dependencies
      if: inputs.build == 'true' && inputs.cache-dependencies == 'true'
      uses: actions/cache@v4
      with:
        path: |
          ${{ inputs.project-path }}/node_modules
          ~/.npm
        key: ${{ runner.os }}-deps-${{ steps.dep-hash.outputs.hash }}
        restore-keys: |
          ${{ runner.os }}-deps-

    - name: Install dependencies
      if: inputs.build == 'true'
      shell: bash
      working-directory: ${{ inputs.project-path }}
      run: |
        SANITY_CLI_PKG="@sanity/cli"
        if [ -n "${{ inputs.cli-version }}" ]; then
          SANITY_CLI_PKG="${SANITY_CLI_PKG}@${{ inputs.cli-version }}"
        fi

        if [ -f "package-lock.json" ]; then
          npm ci
          npm install -g $SANITY_CLI_PKG
        elif [ -f "yarn.lock" ]; then
          yarn install --frozen-lockfile
          yarn install -g $SANITY_CLI_PKG
        elif [ -f "pnpm-lock.yaml" ]; then
          pnpm install --frozen-lockfile
          pnpm install -g $SANITY_CLI_PKG
        else
          npm install
          npm install -g $SANITY_CLI_PKG
        fi
        echo "‚úÖ Dependencies installed"

    - name: Setup environment
      shell: bash
      working-directory: ${{ inputs.project-path }}
      run: |
        # Set project configuration
        echo "SANITY_AUTH_TOKEN=${{ inputs.token }}" >> $GITHUB_ENV

        # Set additional environment variables
        if [ -n "${{ inputs.environment-variables }}" ]; then
          echo "${{ inputs.environment-variables }}" | while IFS= read -r line; do
            if [ -n "$line" ]; then
              export "$line"
              echo "$line" >> $GITHUB_ENV
            fi
          done
        fi

        echo "üîß Deployment environment configured"

    - name: Build project
      id: build-project
      if: inputs.build == 'true'
      shell: bash
      working-directory: ${{ inputs.project-path }}
      run: |
        echo "üî® Building Sanity project..."

        # Run the build command
        BUILD_CMD="sanity build -y"
        MANIFEST_CMD="sanity manifest extract"

        # Add output path
        if [ -n "${{ inputs.output-path }}" ]; then
          BUILD_CMD="$BUILD_CMD ${{ inputs.output-path }}"
          MANIFEST_CMD="$MANIFEST_CMD --path ${{ inputs.output-path }}"
        fi

        # Add optional flags
        if [ "${{ inputs.source-maps }}" = "true" ]; then
          BUILD_CMD="$BUILD_CMD --source-maps"
        fi

        if [ "${{ inputs.no-minify }}" = "true" ]; then
          BUILD_CMD="$BUILD_CMD --no-minify"
        fi

        if [ -n "${{ inputs.schema-path }}" ]; then
          BUILD_CMD="$BUILD_CMD --schema-path ${{ inputs.schema-path }}"
        fi

        echo "Running: $BUILD_CMD"
        eval $BUILD_CMD

        # Verify output exists
        if [ -d "${{ inputs.output-path }}" ]; then
          echo "‚úÖ Build completed successfully"
          echo "path=${{ inputs.project-path }}/${{ inputs.output-path }}" >> $GITHUB_OUTPUT

          # Measure build size
          SIZE=$(du -sh "${{ inputs.output-path }}" | cut -f1)
          echo "size=$SIZE" >> $GITHUB_OUTPUT
          echo "üìè Build size: $SIZE"
        else
          echo "‚ùå Build output directory not found"
          exit 1
        fi

        if [ "${{ inputs.schema-required }}" = "true" ]; then
          eval $MANIFEST_CMD
        fi

    - name: Upload build artifacts
      if: inputs.build == 'true' && inputs.upload-artifacts == 'true'
      uses: actions/upload-artifact@v4
      with:
        name: ${{ inputs.artifact-name }}
        path: ${{ inputs.project-path }}/${{ inputs.output-path }}
        retention-days: 7

    - name: Deploy Studio
      id: deploy-studio
      if: inputs.deploy-studio == 'true'
      shell: bash
      working-directory: ${{ inputs.project-path }}
      run: |
        echo "üöÄ Deploying Sanity Studio..."

        # Build deploy command
        DEPLOY_CMD="sanity deploy --no-build --yes"

        # Execute deployment
        DEPLOY_OUTPUT=$($DEPLOY_CMD 2>&1)
        DEPLOY_EXIT_CODE=$?

        echo "$DEPLOY_OUTPUT"

        if [ $DEPLOY_EXIT_CODE -eq 0 ]; then
          # Extract studio URL from output - looking for "Studio deployed to <URL>"
          STUDIO_URL=$(echo "$DEPLOY_OUTPUT" | grep -o "Studio deployed to https://[^ ]*" | sed 's/Studio deployed to //' | head -n1)

          if [ -z "$STUDIO_URL" ]; then
            # Fallback: try to extract any studio URL
            STUDIO_URL=$(echo "$DEPLOY_OUTPUT" | grep -oE 'https://[^ ]+\.(sanity\.studio|studio\.sanity\.work)' | head -n1)
          fi

          echo "url=$STUDIO_URL" >> $GITHUB_OUTPUT
          echo "id=${{ github.run_id }}-${{ github.run_number }}" >> $GITHUB_OUTPUT
          echo "‚úÖ Studio deployed to: $STUDIO_URL"
        else
          echo "‚ùå Deployment failed"
          exit $DEPLOY_EXIT_CODE
        fi

    - name: Wait for studio deployment
      if: inputs.wait-for-deployment == 'true' && inputs.deploy-studio == 'true' && steps.deploy-studio.outputs.url != ''
      shell: bash
      run: |
        STUDIO_URL="${{ steps.deploy-studio.outputs.url }}"
        TIMEOUT=${{ inputs.deployment-timeout }}
        ELAPSED=0
        INTERVAL=10

        echo "‚è≥ Waiting for deployment to be ready..."

        while [ $ELAPSED -lt $TIMEOUT ]; do
          if curl -sf -o /dev/null "$STUDIO_URL"; then
            echo "‚úÖ Studio is ready!"
            break
          else
            echo "Waiting... ($ELAPSED/$TIMEOUT seconds)"
            sleep $INTERVAL
            ELAPSED=$((ELAPSED + INTERVAL))
          fi
        done

        if [ $ELAPSED -ge $TIMEOUT ]; then
          echo "‚ö†Ô∏è Timeout waiting for deployment to be ready"
        fi

    - name: Create Studio GitHub Deployment
      id: create-studio-deployment
      if: inputs.deploy-studio == 'true' && inputs.create-github-deployment == 'true' && steps.deploy-studio.outputs.url != ''
      uses: actions/github-script@v7
      with:
        github-token: ${{ inputs.github-token || github.token }}
        script: |
          const studioUrl = '${{ steps.deploy-studio.outputs.url }}';
          const deploymentId = '${{ steps.deploy-studio.outputs.id }}';

          try {
            // Create the deployment
            const deployment = await github.rest.repos.createDeployment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: context.sha,
              task: 'deploy:sanity-studio',
              auto_merge: false,
              required_contexts: [],
              payload: {
                web_url: studioUrl,
                description: 'Sanity Studio Deployment',
                deployment_id: deploymentId
              },
              environment: 'sanity-studio',
              description: 'Sanity Studio Deployment',
              transient_environment: context.eventName === 'pull_request',
              production_environment: context.eventName !== 'pull_request'
            });

            console.log('‚úÖ Created deployment:', deployment.data.id);

            // Update the deployment status to success
            await github.rest.repos.createDeploymentStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              deployment_id: deployment.data.id,
              state: 'success',
              target_url: studioUrl,
              description: 'Sanity Studio deployed successfully',
              environment: 'sanity-studio',
              environment_url: studioUrl,
              auto_inactive: false
            });

            console.log('‚úÖ Deployment status updated to success');
          } catch (error) {
            console.error('Failed to create GitHub deployment:', error.message);
            // Don't fail the action if deployment creation fails
          }

    - name: Deploy GraphQL API
      id: deploy-graphql
      if: inputs.deploy-graphql == 'true'
      shell: bash
      working-directory: ${{ inputs.project-path }}
      run: |
        echo "üöÄ Deploying GraphQL API..."

        # Build deploy command
        DEPLOY_CMD="sanity graphql deploy -y"

        if [ -n "${{ inputs.graphql-override-tag }}" ]; then
          DEPLOY_CMD="$DEPLOY_CMD --tag ${{ inputs.graphql-override-tag }}"
        fi

        if [ -n "${{ inputs.graphql-override-dataset }}" ]; then
          DEPLOY_CMD="$DEPLOY_CMD --dataset ${{ inputs.graphql-override-dataset }}"
        fi

        if [ "${{ inputs.graphql-override-playground }}" = "true" ]; then
          BUILD_CMD="$BUILD_CMD --playground"
        else
          BUILD_CMD="$BUILD_CMD --no-playground"
        fi

        if [ -n "${{ inputs.graphql-override-generation }}" ]; then
          DEPLOY_CMD="$DEPLOY_CMD --generation ${{ inputs.graphql-override-generation }}"
        fi

        if [ "${{ inputs.graphql-override-non-null-document-fields }}" = "true" ]; then
          BUILD_CMD="$BUILD_CMD --non-null-document-fields"
        fi

        if [ "${{ inputs.graphql-override-with-union-cache }}" = "true" ]; then
          BUILD_CMD="$BUILD_CMD --with-union-cache"
        fi

        # Execute deployment
        DEPLOY_OUTPUT=$($DEPLOY_CMD 2>&1)
        DEPLOY_EXIT_CODE=$?

        echo "$DEPLOY_OUTPUT"

        if [ $DEPLOY_EXIT_CODE -eq 0 ]; then
          # Extract GraphQL URL from output - looking for "URL:" followed by the URL
          GRAPHQL_URL=$(echo "$DEPLOY_OUTPUT" | grep -oE "URL:\s+https://[^ ]+" | sed 's/URL:\s*//' | head -n1)

          if [ -z "$GRAPHQL_URL" ]; then
            # Fallback: try to extract any GraphQL API URL
            GRAPHQL_URL=$(echo "$DEPLOY_OUTPUT" | grep -oE 'https://[^ ]+\.api\.sanity\.(io|work)/[^ ]+/graphql/[^ ]+' | head -n1)
          fi

          # Construct playground URL from the GraphQL URL
          if [ -n "$GRAPHQL_URL" ]; then
            PLAYGROUND_URL="${GRAPHQL_URL}/playground"
          else
            PLAYGROUND_URL=""
          fi

          echo "url=$GRAPHQL_URL" >> $GITHUB_OUTPUT
          echo "playground=$PLAYGROUND_URL" >> $GITHUB_OUTPUT

          echo "‚úÖ GraphQL API deployed successfully"
          if [ -n "$GRAPHQL_URL" ]; then
            echo "   API endpoint: $GRAPHQL_URL"
            if [ "${{ inputs.graphql-override-playground }}" = "true" ] && [ -n "$PLAYGROUND_URL" ]; then
              echo "   Playground: $PLAYGROUND_URL"
            fi
          fi
        else
          echo "‚ùå GraphQL deployment failed"
          exit $DEPLOY_EXIT_CODE
        fi

    - name: Create GraphQL GitHub Deployment
      id: create-graphql-deployment
      if: inputs.deploy-graphql == 'true' && inputs.create-github-deployment == 'true' && steps.deploy-graphql.outputs.url != ''
      uses: actions/github-script@v7
      with:
        github-token: ${{ inputs.github-token || github.token }}
        script: |
          const graphqlUrl = '${{ steps.deploy-graphql.outputs.url }}';
          const playgroundUrl = '${{ steps.deploy-graphql.outputs.playground }}';

          try {
            // Create the deployment
            const deployment = await github.rest.repos.createDeployment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: context.sha,
              task: 'deploy:sanity-graphql',
              auto_merge: false,
              required_contexts: [],
              payload: {
                web_url: graphqlUrl,
                playground_url: playgroundUrl,
                description: 'Sanity GraphQL API Deployment'
              },
              environment: 'sanity-graphql',
              description: 'Sanity GraphQL API Deployment',
              transient_environment: context.eventName === 'pull_request',
              production_environment: context.eventName !== 'pull_request'
            });

            console.log('‚úÖ Created GraphQL deployment:', deployment.data.id);

            // Update the deployment status to success
            await github.rest.repos.createDeploymentStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              deployment_id: deployment.data.id,
              state: 'success',
              target_url: graphqlUrl,
              description: 'Sanity GraphQL API deployed successfully',
              environment: 'sanity-graphql',
              environment_url: graphqlUrl,
              auto_inactive: false
            });

            console.log('‚úÖ GraphQL deployment status updated to success');
          } catch (error) {
            console.error('Failed to create GitHub deployment:', error.message);
            // Don't fail the action if deployment creation fails
          }

    - name: Comment on PR
      if: |
        inputs.comment-on-pr == 'true' &&
        github.event_name == 'pull_request' &&
        (steps.deploy-studio.outputs.url != '' || steps.deploy-graphql.outputs.url != '')
      uses: actions/github-script@v7
      with:
        script: |
          const studioUrl = '${{ steps.deploy-studio.outputs.url }}';
          const deploymentId = '${{ steps.deploy-studio.outputs.id }}';
          const graphqlUrl = '${{ steps.deploy-graphql.outputs.url }}';
          const graphqlPlayground = '${{ steps.deploy-graphql.outputs.playground }}';
          const dataset = '${{ inputs.dataset }}';
          const buildSize = '${{ steps.build-project.outputs.size }}';
          const buildPath = '${{ steps.build-project.outputs.path }}';

          let comment = `### üöÄ Sanity Deployment Complete!

          **Dataset:** \`${dataset}\`

          `;

          // Build information
          if ('${{ inputs.build }}' === 'true' && buildSize) {
            comment += `#### Build
          üìè **Size:** ${buildSize}
          üìÅ **Output:** \`${buildPath}\``;

            if ('${{ inputs.build-source-maps }}' === 'true') {
              comment += `\n          üó∫Ô∏è **Source Maps:** Included`;
            }
            if ('${{ inputs.no-minify }}' === 'true') {
              comment += `\n          üìù **Minification:** Disabled`;
            }
            if ('${{ inputs.schema-path }}') {
              comment += `\n          üìÑ **Schema:** \`${{ inputs.schema-path }}\``;
            }
            comment += '\n\n';
          }

          if (studioUrl) {
            comment += `#### Studio
          üîó **URL:** ${studioUrl}
          üì¶ **Deployment ID:** ${deploymentId}\n\n`;
          }

          if (graphqlUrl) {
            comment += `#### GraphQL API
          üîó **Endpoint:** ${graphqlUrl}\n`;
            if (graphqlPlayground) {
              const playgroundEnabled = '${{ inputs.graphql-override-playground }}' === 'true' ||
                                       ('${{ inputs.graphql-override-playground }}' === '' && '${{ inputs.deploy-graphql }}' === 'true');
              if (playgroundEnabled) {
                comment += `          üéÆ **Playground:** ${graphqlPlayground}\n`;
              }
            }

            const graphqlTag = '${{ inputs.graphql-override-tag }}' || 'default';
            const graphqlDataset = '${{ inputs.graphql-override-dataset }}' || dataset;
            comment += `          üè∑Ô∏è **Tag:** \`${graphqlTag}\`\n`;
            if (graphqlDataset !== dataset) {
              comment += `          üìä **Dataset:** \`${graphqlDataset}\`\n`;
            }
            comment += '\n';
          }

          comment += `
          ---
          <sub>ü§ñ Deployed by Sanity GitHub Actions at ${new Date().toLocaleString('en-US', { timeZone: 'UTC', dateStyle: 'short', timeStyle: 'medium' })} UTC</sub>`;

          // Find existing comment
          const { data: comments } = await github.rest.issues.listComments({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number: context.issue.number
          });

          const botComment = comments.find(comment =>
            comment.user.type === 'Bot' &&
            comment.body.includes('Sanity Deployment Complete')
          );

          if (botComment) {
            // Update existing comment
            await github.rest.issues.updateComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: botComment.id,
              body: comment
            });
          } else {
            // Create new comment
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: comment
            });
          }
